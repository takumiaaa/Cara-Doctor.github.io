<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>45page</title>
</head>
<style>
    body{
        margin: 0;
        padding: 0;
    }
.draw-area{
    top : 90px;
position: relative;
    border: 2px solid #000;
    display: block;
    margin-left: auto;
    margin-right: auto;
    background-color: #fff;
}

    .back{
        background-image: url(背景.png);
        background-size: cover;
        width: 378px;
        height: 643px;
        display: block;
        margin-left: auto;
        margin-right: auto;
    }
.daimei{
    width: 100px;
    height: auto;
    position: relative;
    top: 70px;
    display: block;
    margin-left: auto;
    margin-right: auto;
}
.keshi{
    width: 20%;
    height: auto;
    position: relative;
    top: 150px;
    left: 33px;
}
.pen{
    width: 20%;
    height: auto;
    position: relative;
    top: 150px;
    right: -195px;
}
.owaru{
    width: 37%;
    height: auto;
    position:relative;
    top: 150px;
    left: -40px;
}

</style>
<script>
    // ページの読み込みが完了したらコールバック関数が呼ばれる
// ※コールバック: 第2引数の無名関数(=関数名が省略された関数)
window.addEventListener('load', () => {
  const canvas = document.querySelector('.draw-area');
  // contextを使ってcanvasに絵を書いていく
  const context = canvas.getContext('2d');
 
  // 直前のマウスのcanvas上のx座標とy座標を記録する
  const lastPosition = { x: null, y: null };
 
  // マウスがドラッグされているか(クリックされたままか)判断するためのフラグ
  let isDrag = false;
 
  // 絵を書く
  function draw(x, y) {
    // マウスがドラッグされていなかったら処理を中断する。
    // ドラッグしながらしか絵を書くことが出来ない。
    if(!isDrag) {
      return;
    }
 
    // 「context.beginPath()」と「context.closePath()」を都度draw関数内で実行するよりも、
    // 線の描き始め(dragStart関数)と線の描き終わり(dragEnd)で1回ずつ読んだほうがより綺麗に線画書ける
 
    // 線の状態を定義する
    // MDN CanvasRenderingContext2D: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/lineJoin
    context.lineCap = 'round'; // 丸みを帯びた線にする
    context.lineJoin = 'round'; // 丸みを帯びた線にする
    context.lineWidth = 3; // 線の太さ
   
   
    context.strokeStyle = `rgb(${G_colorData1_R},
      ${G_colorData1_G},
      ${G_colorData1_B})`; // 線の色
 



    // 書き始めは lastPosition.x, lastPosition.y の値はnullとなっているため、
    // クリックしたところを開始点としている。
    // この関数(draw関数内)の最後の2行で lastPosition.xとlastPosition.yに
    // 現在のx, y座標を記録することで、次にマウスを動かした時に、
    // 前回の位置から現在のマウスの位置まで線を引くようになる。
    if (lastPosition.x === null || lastPosition.y === null) {
      // ドラッグ開始時の線の開始位置
      context.moveTo(x, y);
    } else {
      // ドラッグ中の線の開始位置
      context.moveTo(lastPosition.x, lastPosition.y);
    }
    // context.moveToで設定した位置から、context.lineToで設定した位置までの線を引く。
    // - 開始時はmoveToとlineToの値が同じであるためただの点となる。
    // - ドラッグ中はlastPosition変数で前回のマウス位置を記録しているため、
    //   前回の位置から現在の位置までの線(点のつながり)となる
    context.lineTo(x, y);
 
    // context.moveTo, context.lineToの値を元に実際に線を引く
    context.stroke();
 
    // 現在のマウス位置を記録して、次回線を書くときの開始点に使う
    lastPosition.x = x;
    lastPosition.y = y;
  }
 
  // canvas上に書いた絵を全部消す
  function clear() {
    context.clearRect(0, 0, canvas.width, canvas.height);
  }
 
  // マウスのドラッグを開始したらisDragのフラグをtrueにしてdraw関数内で
  // お絵かき処理が途中で止まらないようにする
  function dragStart(event) {
    // これから新しい線を書き始めることを宣言する
    // 一連の線を書く処理が終了したらdragEnd関数内のclosePathで終了を宣言する
    context.beginPath();
 
    isDrag = true;
  }
  // マウスのドラッグが終了したら、もしくはマウスがcanvas外に移動したら
  // isDragのフラグをfalseにしてdraw関数内でお絵かき処理が中断されるようにする
  function dragEnd(event) {
    // 線を書く処理の終了を宣言する
    context.closePath();
    isDrag = false;
 
    // 描画中に記録していた値をリセットする
    lastPosition.x = null;
    lastPosition.y = null;
  }
 
  // マウス操作やボタンクリック時のイベント処理を定義する
  function initEventHandler() {
    const clearButton = document.querySelector('.keshi');
    clearButton.addEventListener('click', clear);
 
    canvas.addEventListener('mousedown', dragStart);
    canvas.addEventListener('mouseup', dragEnd);
    canvas.addEventListener('mouseout', dragEnd);
    canvas.addEventListener('mousemove', (event) => {
      // eventの中の値を見たい場合は以下のようにconsole.log(event)で、
      // デベロッパーツールのコンソールに出力させると良い
      // console.log(event);
 
      draw(event.layerX, event.layerY);
    });
  }
 
  // イベント処理を初期化する
  initEventHandler();
});







        //各RGBを格納するグローバル変数を定義しました
        let G_colorData1_R;
        let G_colorData1_G;
        let G_colorData1_B;

        let G_colorData2_R;
        let G_colorData2_G;
        let G_colorData2_B;

        //async function data1() {
        async function data1() {
            let port;
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                while (port.readable) {
                    const reader = port.readable.getReader();
                    try {
                        while (true) {
                            const { value, done } = await reader.read();
                            if (done) {
                                addSerial("Canceled\n");
                                break;
                            }
                            const inputValue = new TextDecoder().decode(value);
                            addSerial(inputValue);
                        }
                    } catch (error) {
                        addSerial("Error: Read" + error + "\n");
                    } finally {
                        reader.releaseLock();
                    }
                }
            }
            catch (error) {
                addSerial("Error: Open" + error + "\n");
            }


            function addSerial(msg) {
                var textarea = document.getElementById('outputArea');
                let colorInfo1 = document.getElementById("colorInfo1");
                let data = msg.split(",");

                if (data.length === 3) {
                    let colorData1 = { R: data[0], G: data[1], B: data[2] };
                    colorInfo1.style.backgroundColor = `rgba(${colorData1.R},${colorData1.G},${colorData1.B},1)`;
                    G_colorData1_R = colorData1.R;
                    G_colorData1_G = colorData1.G;
                    G_colorData1_B = colorData1.B;
                }
            }
        }

        //onclickからの値を引数で読み込むために少し変えています．シリアルから読み込む時は変更不要　井上
        async function data2() {
            let port;
            try {
                port = await navigator.serial.requestPort();
                await port.open({ baudRate: 115200 });
                while (port.readable) {
                    const reader = port.readable.getReader();
                    try {
                        while (true) {
                            const { value, done } = await reader.read();
                            if (done) {
                                addSerial("Canceled\n");
                                break;
                            }
                            const inputValue = new TextDecoder().decode(value);
                            addSerial(inputValue);
                        }
                    } catch (error) {
                        addSerial("Error: Read" + error + "\n");
                    } finally {
                        reader.releaseLock();
                    }
                }
            } catch (error) {
                addSerial("Error: Open" + error + "\n");
            }





            function addSerial(msg) {
                var textarea = document.getElementById('outputArea');
                let colorInfo2 = document.getElementById("colorInfo2");
                let data = msg.split(",");


                if (data.length === 3) {
                    let colorData2 = { R: data[0], G: data[1], B: data[2] };
                    colorInfo2.style.backgroundColor = `rgba(${colorData2.R},${colorData2.G},${colorData2.B},1)`;
                    console.log(colorData2.B);

                    //2回目のデータをグローバル変数に格納
                    G_colorData2_R = colorData2.R;
                    G_colorData2_G = colorData2.G;
                    G_colorData2_B = colorData2.B;
                }

            }
        }


        //ここのコメントアウトを外しました
        function data3() {
            let colorInfo3 = document.getElementById("colorInfo3");

            //グローバル変数から混色を作成
            //Math.floor関数で整数部分のみ使う
            //Numberで文字型から数値型へ変換
            colorData3_R = Math.floor((Number(G_colorData1_R) + Number(G_colorData2_R)) / 2);
            colorData3_G = Math.floor((Number(G_colorData1_G) + Number(G_colorData2_G)) / 2);
            colorData3_B = Math.floor((Number(G_colorData1_B) + Number(G_colorData2_B)) / 2);


            //配列ではなく，変数に変更
            colorInfo3.style.backgroundColor = `rgba(${colorData3_R},${colorData3_G},${colorData3_B},1)`;


            console.log(colorData3_R);
            console.log(colorData3_G);
            console.log(colorData3_B);

        }
</script>
<body>
<div class="sample_box1">
    <div class="back">
    <img class="daimei" src="45ページ\dai mei 45.png">
        <canvas class="draw-area"
        height= "250px"
        width="250px"></canvas>

        <div id="colorInfo1">
         <script src="./oekaki.js"></script>
        </div>
    <img class="keshi" src="45ページ\kesi 45.png">
    <img class="pen" src="45ページ\pen 45.png" onclick="data1()">
    <a href="31page.html">
    <img class="owaru" src="45ページ\owaru big.png">
</a>
    </div>
</div>    
</body>
</html>
